-- 서브 쿼리 : SQL 문장안에서 다시 사용되는 SELECT 문
-- 단일행 서브쿼리 : 서브쿼리 결과가 1행이하인 서브쿼리

-- 낸시보다 급여가 높은사람
-- 낸시의 급여를 찾고, 찾은 급여를 WHERE 절에 넣는다

SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy';
SELECT * FROM EMPLOYEES WHERE SALARY >= 12008;
SELECT * FROM EMPLOYEES WHERE SALARY >= (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy');

-- 103번과 직업이 같은 사람
SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 103;
SELECT * FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 103);

-- 주의할 점 
-- 비교할 컬럼은 정확히 한 개 여야 합니다.
SELECT *
FROM EMPLOYEES
WHERE JOB_ID = (SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 103);

-- 결과가 여러행이 나오는 구문이라면 다중행 서브쿼리 연산자를 써줘야 합니다
SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Steven';
SELECT * 
FROM EMPLOYEES
WHERE SALARY >= (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Steven');

-- 다중행 서브쿼리
-- 서브쿼리의 결과가 여러행 리턴되는 경우
-- IN : 목록의 어떤 값과 같은지 확인함
-- ANY, SOME : 값을 서브쿼리에 의해 리턴된 각각의 값과 비교합니다
-- ALL : 값을 서브쿼리에 의해 리턴된 모든값과 비교합니다. 모든 값과 비교해서 만족해야함

SELECT SALARY
FROM EMPLOYEES
WHERE FIRST_NAME = 'David';

SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY > ANY (SELECT SALARY -- 연산자 붙이고, 비교연산자 써주고
FROM EMPLOYEES
WHERE FIRST_NAME = 'David');

SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SALARY > ALL (SELECT SALARY
FROM EMPLOYEES
WHERE FIRST_NAME = 'David');

-- IN 구문 : 일치하는 데이터만 추출
SELECT FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID FROM EMPLOYEES WHERE FIRST_NAME = 'David');

-- 스칼라 쿼리 : SELECT문에 서브쿼리가 들어간 것
-- join 한 것 처럼 결과가 나옴
-- 특정 테이블의 1개 컬럼만 가져올 때 유용함
SELECT FIRST_NAME,
        DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
-- 위를 스칼라 쿼리를 써본다면
SELECT FIRST_NAME,
        (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D
        WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID) AS DEPARTMENT_NAME
FROM EMPLOYEES E;

-- 스칼라 쿼리는 다른 데이블의 1개 컬럼을 가지고 올때 조인보다 구문이 깔끔
SELECT FIRST_NAME,
       JOB_ID,
       (SELECT JOB_TITLE FROM JOBS J 
       WHERE J.JOB_ID = E.JOB_ID) AS JOB_TITLE

FROM EMPLOYEES E;
-- 많은 컬럼을 가져올때는 JOIN 구문 사용하는게 나음
SELECT FIRST_NAME,
       JOB_ID,
       (SELECT JOB_TITLE FROM JOBS J 
       WHERE J.JOB_ID = E.JOB_ID) AS JOB_TITLE,
       (SELECT MIN_SALARY FROM JOBS J WHERE J.JOB_ID = E.JOB_ID) AS MIN_SALARY
FROM EMPLOYEES E;

-- 예시
--FIRST_NAME, DEPARTMENT_NAME, JOB_TITLE 을 동시에 SELECT
SELECT FIRST_NAME,
       (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D
       WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID) AS 부서명,
       (SELECT JOB_TITLE FROM JOBS J
       WHERE E.JOB_ID = J.JOB_ID) AS 직책
FROM EMPLOYEES E;

-- 조인구문으로한다면
SELECT E.FIRST_NAME,
       J.JOB_TITLE,
       D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT JOIN JOBS J ON E.JOB_ID = J.JOB_ID
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- 인라인 뷰 : FROM절에 들어가는 서브쿼리
-- 인라인 뷰에서 가상컬럼을 만들고, 그 칼럼에 대해서 조회해 나갈때 사용합니다

SELECT *
FROM ( SELECT * 
       FROM EMPLOYEES);
-- 왜 쓰냐?
--ROWNUM 은 조회된 순서에 대해 번호가 붙음
SELECT ROWNUM,
       FIRST_NAME,
       SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;
-- ORDER를 먼저 시킨 결과에 대해서 재조회를 하면
SELECT ROWNUM,FIRST_NAME,SALARY
FROM (SELECT FIRST_NAME,
       SALARY
       FROM EMPLOYEES
       ORDER BY SALARY DESC)
WHERE ROWNUM BETWEEN 11 AND 20; -- ROWNUM은 반드시 시작이 1이어야함 즉 중간부터 조회가 안됨

-- ORDER를 먼저 시킨 결과를 만들고, ROWNUM 가상컬럼로 다시만들고, 재조회
SELECT *
FROM (SELECT ROWNUM AS RNUM, --가상컬럼
       FIRST_NAME,
       SALARY
        FROM (SELECT FIRST_NAME,
       SALARY
        FROM EMPLOYEES
        ORDER BY SALARY DESC))
WHERE RNUM BETWEEN 11 AND 20;-- 가상컬럼을 사용가능
-- 데이터 순서 추출시 유용

--예시
-- 근속년수가 5년인 사람만 출력하려면?
SELECT *
FROM (
SELECT FIRST_NAME,
       HIRE_DATE,
       TRUNC ((SYSDATE-HIRE_DATE)/365) AS 근속년수
FROM EMPLOYEES
ORDER BY 근속년수 DESC
)
WHERE MOD(근속년수,5) = 0;

-- 인라인 뷰에서 테이블 엘리어스로 조회
SELECT  ROWNUM AS RN,
        A.*
       
FROM (
       SELECT E.*,
       TRUNC ((SYSDATE-HIRE_DATE)/365) AS 근속년수
        FROM EMPLOYEES E
        ORDER BY 근속년수 DESC
) A;


